// 走迷宫

// 用回溯法来解
// 将矩阵a[m][n]的每个元素所在位置从左至右从上至下进行编号
// 这里的解题思路是每个格子从上到下，从左到右依次进行编号，
// 通过传入格子的编号求出行号和列号


#include <stdio.h>



// dr[4]存储行号的变化，dc[4]存储列号的变化，
// 从当前格子朝左走，行号不变，列号减一,故dr[0] = 0,dc[0] = -1;
// 从当前格子朝下走，行号加一，列号不变,故dr[1] = 1,dc[1] = 0;
// 从当前格子朝右走，行号不变，列号加一,故dr[2] = 0,dc[2] = 1;
// 从当前格子朝上走，行号减一，列号不变,故dr[3] = -1,dc[3] = 0.
int dr[4] = {0, 1, 0, -1};  // 朝左下右上移动时的行号变化
int dc[4] = {-1, 0, 1, 0};  //朝左下右上移动时的列号变化
int m, n;  // 迷宫的行数m和列数n
int erow, ecol; // 入口的行号和列号
int crow, ccol; // 出口的行号和列号
int a[20][20]; // 将迷宫矩阵存储在数组a[m][n]中

// 传入的参数t为当前格子的编号
void dfs(int t);

int main()
{
	int i, j;

	// 读入数据
	scanf("%d %d",&m, &n);
	scanf("%d %d",&erow, &ecol);
	scanf("%d %d",&crow, &ccol);
	for(i = 0; i < m; i++)
	{
		for(j = 0; j < n; j++)
		{
			scanf("%d",&a[i][j]);
		}
	}

	// 将行号和列号转换为编号，用回溯法求解 
	// 格子编号可以由该格子的行号和列号求出
	// 求法就是行号*总列数+列号
	dfs(erow * n + ecol);

	// 最后只需要判断出口格子有没有被访问过即可
	// 当出口格子被标记为2时，说明被访问过了，否则没有
	if(a[crow][ccol] == 2)
	{
		printf("Yes\n");
	}
	else
	{
		printf("No\n");
	}
}

void dfs(int t)
{
	int row, col; //没移动之前的坐标值,也可以说成是当前坐标
	int r, c; // 移动后的坐标值
	int i; // 左，下，右，上四种情况

	// 当前格子的行号和列号由格子编号求出
	row = t / n; // 格子行号为 格子编号除矩阵列数
	col = t % n; // 格子列号为 格子编号对矩阵列数取余

	//该格子被访问过了，标记为2 
	a[row][col] = 2;

	// 行坐标的变化存储在dr[4]中
	// 列坐标的变化存储在dc[4]中
	// 0表示左，1表示下，2表示右，3表示上
	// 从当前位置开始分别朝左下右上四个方向走，找出一条能走到出口的路径
	for(i = 0; i < 4; i++)
	{
		r = row + dr[i]; // 移动之后的行号
		c = col + dc[i]; // 移动之后的列号
		// 移动后的行号和列号均没有超出矩阵坐标范围，且这个位置标记为0（不是墙，且没被走过）
		// 则这个走法可行，继续寻找路径
		if(r >= 0 && r < m && c >= 0 && c < n && a[r][c] == 0)
		{
			dfs(r * n + c);
		}
	}
}